class t{constructor(t,e){this.viewport=t,this.alignment=e}}class e extends t{getOverflowed(t){const e=this.viewport,i=window.innerWidth-(t.x+t.width),n=window.innerWidth-this.viewport.right;return{left:Math.max(e.left-t.x,0),right:Math.max(n-i,0),top:Math.max(e.top-t.y,0),bottom:Math.max(t.y+t.height-e.bottom,0)}}}class i{static merge(t,e){var i,n,r,s;return new DOMRect(null!==(i=e.x)&&void 0!==i?i:t.x,null!==(n=e.y)&&void 0!==n?n:t.y,null!==(r=e.width)&&void 0!==r?r:t.width,null!==(s=e.height)&&void 0!==s?s:t.height)}}class n{constructor(t,e,i){this.rect=t,this.viewport=e,this.alignment=i}performLayout(t){let e=this.rect,n=t.getOverflowed(e);return 0!=n.left?(e=i.merge(e,{x:e.x+n.left}),n=t.getOverflowed(e),n.right&&(e=i.merge(e,{width:e.width-n.right}))):0!=n.right&&(e=i.merge(e,{x:e.x-Math.max(n.right,this.viewport.left)}),n=t.getOverflowed(e),n.left&&(e=i.merge(e,{x:e.x+n.left,width:e.width-n.left}))),e}}class r{reflow(t,e){return null!=(null==e?void 0:e.width)&&(t.style.width=`${e.width}px`),null!=(null==e?void 0:e.height)&&(t.style.height=`${e.height}px`),null!=e.x&&(t.style.left=`${e.x}px`),null!=e.y&&(t.style.top=`${e.y}px`),t.getBoundingClientRect()}}class s extends r{createOverlayConstraint(t,i){return new e(t,i)}}const o=new class extends s{performLayout(t){var e,r;const s=t.target.getBoundingClientRect(),o=t.parent.getBoundingClientRect(),h=t.behavior.alignment,a=null!==(e=null==h?void 0:h.x)&&void 0!==e?e:l.ALL;null!==(r=null==h?void 0:h.y)&&void 0!==r||l.ALL;let d=t.getBoundingClientRect();const c=s.x+(s.width-d.width)/2,w=s.bottom;d=i.merge(d,{x:c,y:w});const p=this.createOverlayConstraint(o,l.ALL);return d=new n(d,o,a).performLayout(p),d=this.reflow(t,d),{x:d.x,y:d.y,size:{width:d.width,height:d.height}}}};var l;!function(t){t.ALL="all",t.VERTICAL="vertical",t.HORIZONTAL="horizontal"}(l||(l={}));class h{static attach(t,e,i=document.body,n={render:o}){if(null==t)throw new Error("todo");if(null==e)throw new Error("todo");if(null==i)throw new Error("todo");const r=document.createElement("overlay-wrapper");return r.append(t),r.target=e,r.parent=i,r.behavior=n,this.overlays.set(t,r),i.append(r),r}static detach(t){console.log(this.overlays.get(t))}}h.overlays=new Map;class a extends HTMLElement{markNeedRepaint(){this.unsetLayout(),this.performLayout()}unsetLayout(){this.style.width="max-content",this.style.height="max-content",this.style.left="0px",this.style.top="0px",this.getBoundingClientRect()}disconnectedCallback(){this.observer.disconnect(),window.removeEventListener("resize",this.markNeedRepaint.bind(this)),window.removeEventListener("scroll",this.markNeedRepaint.bind(this))}connectedCallback(){this.style.display="block",this.style.position="fixed",this.style.left="0px",this.style.top="0px",this.style.width="max-content",this.style.height="max-content",this.performLayout(),this.observer=new MutationObserver(this.markNeedRepaint.bind(this)),this.observer.observe(this.firstElementChild,{attributes:!0,characterData:!0,subtree:!0,childList:!0}),window.addEventListener("resize",this.markNeedRepaint.bind(this)),window.addEventListener("scroll",this.markNeedRepaint.bind(this))}performLayout(){const t=this.behavior.render.performLayout(this);this.style.width=`${t.size.width}px`,this.style.height=`${t.size.height}px`,this.style.left=`${t.x}px`,this.style.top=`${t.y}px`}}customElements.define("overlay-wrapper",a);export{h as Overlay,l as OverlayAlignment,a as OverlayElement,r as OverlayRender};
//# sourceMappingURL=index.esm.js.map
