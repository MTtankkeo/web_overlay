const e={AUTO:"auto",AUTO_LEFT:"auto_left",AUTO_RIGHT:"auto_right",AUTO_CENTER:"auto_center"};class t{static attach(t,o,s=document.body,i=e.AUTO){if(null==t)throw new Error("todo");if(null==o)throw new Error("todo");if(null==s)throw new Error("todo");const n=document.createElement("overlay-wrapper");return n.append(t),this.overlays.set(t,n),s.append(n),n}static detach(e){console.log(this.overlays.get(e))}}t.overlays=new Map;class o{static get tolerance(){return.3}measureSize(e){const t=e.getBoundingClientRect(),s=e.clientWidth/t.width,i=e.clientHeight/t.height,n=o.tolerance;return{x:t.x,y:t.y,size:{width:t.width*s+n,height:t.height*i+n}}}reflow(e){e.getBoundingClientRect()}}class s extends o{performLayout(e,t,o){const s=this.measureSize(e),i=this.measureSize(o);this.measureSize(t);const n={x:Math.max(s.size.width-i.size.width,0),y:Math.max(s.size.height-i.size.height,0)};return{x:n.x,y:n.y,size:s.size}}}class i extends HTMLElement{constructor(){super(...arguments),this.render=new s}connectedCallback(){this.style.display="block",this.style.width="fit-content",this.style.height="fit-content";const e=this.render.performLayout(this,document.body,document.body);console.log(e)}}customElements.define("overlay-wrapper",i);export{t as Overlay,e as OverlayAlignment,i as OverlayElement,o as OverlayRender};
//# sourceMappingURL=index.esm.js.map
